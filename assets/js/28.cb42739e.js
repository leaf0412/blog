(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{481:function(e,n,t){"use strict";t.r(n);var d=t(4),a=Object(d.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"key-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-是什么"}},[e._v("#")]),e._v(" key 是什么")]),e._v(" "),t("p",[t("code",[e._v("key 是给每个 vnode 的唯一 id， 也是 diff 的一种优化策略，可以根据 key，更准确，更快的找到对应的 vnode 节点")])]),e._v(" "),t("p",[e._v("当我们在使用 v-for 时，需要给单元加上 key")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<ul>\n    <li v-for="item in items" :key="item.id">...</li>\n</ul>\n')])])]),t("p",[e._v("用+new Date()生成的时间戳作为 key，手动强制触发重新渲染")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<Comp :key="+new Date()" />\n')])])]),t("p",[e._v("场景 1: 当我们在使用 v-for 时，需要给单元加上 key")]),e._v(" "),t("p",[e._v("如果不用 key，Vue 会采用就地复地原则：最小化 element 的移动，并且会尝试尽最大程度在同适当的地方对相同类型的 element ，做 patch 或者 reuse 。")]),e._v(" "),t("p",[e._v("如果使用了 key，Vue 会根据 keys 的顺序记录 element，曾经拥有了 key 的 element 如果不再出现的话，会被直接 remove 或者 destoryed")]),e._v(" "),t("p",[e._v("场景 2: 用 +new Date() 生成的时间戳作为 key，手动强制触发重新渲染")]),e._v(" "),t("p",[e._v("当拥有新值的 rerender 作为 key 时，拥有了新 key 的 Comp 出现了，那么旧 key Comp 会被移除，新 key Comp 触发渲染")]),e._v(" "),t("h2",{attrs:{id:"设置-key-与不设置-key-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置-key-与不设置-key-区别"}},[e._v("#")]),e._v(" 设置 key 与不设置 key 区别")]),e._v(" "),t("p",[e._v("举个例子：\n创建一个实例，2 秒后往 items 数组插入数据")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<body>\n  <div id=\"demo\">\n    <p v-for=\"item in items\" :key=\"item\">{{item}}</p>\n  </div>\n  <script src=\"../../dist/vue.js\"><\/script>\n  <script>\n    // 创建实例\n    const app = new Vue({\n      el: '#demo',\n      data: { items: ['a', 'b', 'c', 'd', 'e'] },\n      mounted () {\n        setTimeout(() => {\n          this.items.splice(2, 0, 'f')  //\n       }, 2000);\n     },\n   });\n  <\/script>\n</body>\n")])])]),t("p",[e._v("在不使用 key 的情况，vue 会进行这样的操作：")]),e._v(" "),t("p",[e._v("分析下整体流程：")]),e._v(" "),t("ul",[t("li",[e._v("比较 A，A，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 B，B，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 C，F，相同类型的节点，进行 patch，数据不同，发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 D，C，相同类型的节点，进行 patch，数据不同，发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 E，D，相同类型的节点，进行 patch，数据不同，发生 dom 操作")]),e._v(" "),t("li",[e._v("循环结束，将 E 插入到 DOM 中")])]),e._v(" "),t("p",[e._v("一共发生了 3 次更新，1 次插入操作")]),e._v(" "),t("p",[e._v("在使用 key 的情况：vue 会进行这样的操作：")]),e._v(" "),t("ul",[t("li",[e._v("比较 A，A，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 B，B，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 C，F，不相同类型的节点")]),e._v(" "),t("li",[e._v("比较 E、E，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 D、D，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("比较 C、C，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作")]),e._v(" "),t("li",[e._v("循环结束，将 F 插入到 C 之前")])]),e._v(" "),t("p",[e._v("一共发生了 0 次更新，1 次插入操作")]),e._v(" "),t("p",[e._v("通过上面两个小例子，可见设置 key 能够大大减少对页面的 DOM 操作，提高了 diff 效率")]),e._v(" "),t("p",[e._v("设置 key 值一定能提高 diff 效率吗？")]),e._v(" "),t("p",[e._v("其实不然，文档中也明确表示")]),e._v(" "),t("p",[e._v("当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素")]),e._v(" "),t("p",[e._v("这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出")]),e._v(" "),t("p",[e._v("建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升")]),e._v(" "),t("h2",{attrs:{id:"原理分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理分析"}},[e._v("#")]),e._v(" 原理分析")]),e._v(" "),t("p",[e._v("源码位置：core/vdom/patch.js")]),e._v(" "),t("p",[e._v("这里判断是否为同一个 key，首先判断的是 key 值是否相等如果没有设置 key，那么 key 为 undefined，这时候 undefined 是恒等于 undefined")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sameVnode (a, b) {\n    return (\n        a.key === b.key && (\n            (\n                a.tag === b.tag &&\n                a.isComment === b.isComment &&\n                isDef(a.data) === isDef(b.data) &&\n                sameInputType(a, b)\n            ) || (\n                isTrue(a.isAsyncPlaceholder) &&\n                a.asyncFactory === b.asyncFactory &&\n                isUndef(b.asyncFactory.error)\n            )\n        )\n    )\n}\n// updateChildren 方法中会对新旧 vnode 进行 diff，然后将比对出的结果用来更新真实的 DOM\nfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    ...\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n            ...\n        } else if (isUndef(oldEndVnode)) {\n            ...\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n            ...\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n            ...\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n            ...\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n            ...\n        } else {\n            if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n            idxInOld = isDef(newStartVnode.key)\n                ? oldKeyToIdx[newStartVnode.key]\n                : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n            if (isUndef(idxInOld)) { // New element\n                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n            } else {\n                vnodeToMove = oldCh[idxInOld]\n                if (sameVnode(vnodeToMove, newStartVnode)) {\n                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n                    oldCh[idxInOld] = undefined\n                    canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n                } else {\n                    // same key but different element. treat as new element\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n                }\n            }\n            newStartVnode = newCh[++newStartIdx]\n        }\n    }\n    ...\n}\n")])])]),t("p",[e._v("参考文献")]),e._v(" "),t("p",[e._v("https://juejin.cn/post/6844903826693029895")]),e._v(" "),t("p",[e._v("https://juejin.cn/post/6844903985397104648")]),e._v(" "),t("p",[e._v("https://vue3js.cn/docs/zh")])])}),[],!1,null,null,null);n.default=a.exports}}]);